name: Docker build and push template
on:
  push:
    branches:
      - "main"
  schedule:
    - cron: '0 11 * * 0,1,2,3,4,5'
  workflow_dispatch:
permissions:
  actions: write
jobs:
  setup-environment:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install required PHP XML extension
        run: |
          sudo apt-get update
          # Try packages in order of preference
          for pkg in php-xml php8.3-xml php8.2-xml php8.1-xml; do
            if sudo apt-get install -y "$pkg" 2>/dev/null; then
              echo "Successfully installed $pkg"
              exit 0
            fi
          done
          echo "Warning: Could not install PHP XML extension"

      - name: Start services with docker-compose
        run: |
          if [ -f docker-compose.yml ]; then
            docker-compose up -d
          fi

      - name: Diagnostic logs after docker-compose up
        run: |
          echo "--- Diagnostic: docker ps ---"
          docker ps --format 'table {{.ID}}\t{{.Image}}\t{{.Names}}\t{{.Status}}'
          echo ""
          echo "--- Diagnostic: docker-compose ps ---"
          docker-compose ps || true
          echo ""
          echo "--- Diagnostic: container logs (tail 200) ---"
          for container in $(docker ps -q); do
            echo "=== Logs for container $(docker inspect --format '{{.Name}}' $container) ==="
            docker logs --tail 200 "$container" 2>&1 || true
          done

      - name: Wait for etcd and MinIO (with logs on failure)
        run: |
          set -euo pipefail
          
          # Configuration
          MAX_RETRIES=120
          RETRY_INTERVAL=5
          
          check_http() {
            url="$1"
            name="$2"
            i=0
            while [ $i -lt $MAX_RETRIES ]; do
              i=$((i + 1))
              if curl -fsS --max-time 5 "$url" >/dev/null 2>&1; then
                echo "${name} is healthy"
                return 0
              fi
              sleep $RETRY_INTERVAL
            done
            return 1
          }

          echo "--- Diagnostic: containers and compose status ---"
          docker ps --format 'table {{.ID}}\t{{.Image}}\t{{.Names}}\t{{.Status}}'
          docker-compose ps || true

          # etcd health: try etcdctl first if present
          if command -v etcdctl >/dev/null 2>&1; then
            if ! etcdctl --endpoints="http://localhost:2379" endpoint health --write-out=table >/dev/null 2>&1; then
              echo "etcdctl health check failed"
              docker logs etcd --tail 200 || true
              exit 1
            fi
          else
            if ! check_http "http://localhost:2379/health" "etcd"; then
              echo "etcd HTTP health check failed"
              docker logs etcd --tail 200 || true
              exit 1
            fi
          fi

          if ! check_http "http://localhost:9000/minio/health/live" "minio"; then
            echo "MinIO health check failed"
            docker logs minio --tail 200 || true
            exit 1
          fi

      - name: Cleanup containers and networks
        if: always()
        run: |
          set -euo pipefail
          if [ -f docker-compose.yml ]; then
            docker-compose -f docker-compose.yml down --remove-orphans --volumes --timeout 30 || true
          fi
          # Get all github_network* networks
          networks=$(docker network ls --filter "name=github_network" --format "{{.Name}}" 2>/dev/null || true)
          if [ -n "$networks" ]; then
            # Collect and stop unique containers from all networks
            containers_to_stop=""
            for network in $networks; do
              container_ids=$(docker ps -q --filter "network=$network" 2>/dev/null || true)
              if [ -n "$container_ids" ]; then
                containers_to_stop="$containers_to_stop $container_ids"
              fi
            done
            # Stop unique containers
            if [ -n "$containers_to_stop" ]; then
              echo "$containers_to_stop" | tr ' ' '\n' | sort -u | xargs -r docker stop || true
              sleep 3
            fi
            # Remove networks
            for network in $networks; do
              docker network rm "$network" || true
            done
          fi

  build-application:
    needs: setup-environment
    uses: drupalforge/docker_publish_action/.github/workflows/docker-publish.yml@dries_note_vienna_2025
    with:
      dockerhub_username: ${{ vars.DOCKERHUB_USERNAME }}
    secrets:
      dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
      openai_key: ${{ secrets.OPENAI_KEY }}
